#!/usr/bin/perl

use strict;
use warnings;
use v5.6.1;
use IO::Select;
use IO::Socket;
use Socket;

# Some initialization:

###############################################################################
# We're just gonna get this out of the way right now because it's big and ugly.
# These define all the server numerics.
#
# Note: Numeric 462 was originally ERR_ALREADYREGISTRED (not REGISTERED).
# Why this legacy typo has stayed in for so long is beyond me.
# I'm taking it out.
###############################################################################
my $RPL_WELCOME           = '001';
my $RPL_YOURHOST          = '002';
my $RPL_CREATED           = '003';
my $RPL_LUSERCLIENT       = '251';
my $RPL_LUSEROP           = '252';
my $RPL_LUSERUNKNOWN      = '253';
my $RPL_LUSERCHANNELS     = '254';
my $RPL_LUSERME           = '255';
my $RPL_LOCALUSERS        = '265';
my $RPL_GLOBALUSERS       = '266';
my $RPL_WHOISUSER         = '311';
my $RPL_WHOISSERVER       = '312';
my $RPL_ENDOFWHOIS        = '318';
my $RPL_MOTD              = '372';
my $RPL_MOTDSTART         = '375';
my $RPL_ENDOFMOTD         = '376';
my $ERR_NOSUCHNICK        = '401';
my $ERR_UNKNOWNCOMMAND    = '421';
my $ERR_NOMOTD            = '422';
my $ERR_NONICKNAMEGIVEN   = '431';
my $ERR_ERRONEUSNICKNAME  = '432';
my $ERR_NICKNAMEINUSE     = '433';
my $ERR_NOTREGISTERED     = '451';
my $ERR_NEEDMOREPARAMS    = '461';
my $ERR_ALREADYREGISTERED = '462';
###############################################################################

my %users  = ();  # Hash containing all filehandles of clients and their info. Ex. $users{$filehandle}{nick}
my %local  = ();  # Hash containing all local info for the server. Ex. $local{users}
my %global = ();  # Hash containing all global info for the network. Ex. $global{users}
my %fhs    = ();  # Hash containing nicks and their filehandles. Ex. $fhs{nick}

my @clients_to_disconnect = (); # Array containing a list of filehandles that have disconnected.

# Will be replaced to be read from a config file later.
$local{version}     = 'Veachian-0.10';
$local{network}     = 'V64net';
$local{server}      = 'G42.V64.net';
$local{server_desc} = 'The Veachian IRCd - Written entirely in the Perl programming language.';
$local{start_date}  =  get_date();
$local{motd_file}   = 'vircd.motd';
$local{port}        = '4242';
$local{buf_size}    = '9999';

$local{users} = 0;
$global{users} = 0;
$local{record_users} = 0;
$global{record_users} = 0;
$local{invisible_users} = 0;
$global{invisible_users} = 0;
$local{non_invisible_users} = 0;
$global{non_invisible_users} = 0;
$local{servers} = 0;
$global{servers} = 1;
$local{operators} = 0;
$global{operators} = 0;
$local{channels} = 0;
$global{channels} = 0;

print "Starting $local{version}......";

$local{listen} = IO::Socket::INET->new(LocalPort => $local{port},
                                       Listen    => 10,
                                       Proto     => 'tcp',
                                       Reuse     => 1)
or die "Unable to creating listening socket.\n";

$local{reader} = IO::Select->new();
$local{reader}->add($local{listen});
$local{sender} = IO::Select->new();
$local{sender}->add($local{listen});

print "Server running.\n";

while (1) {
    my @sockets = IO::Select->select($local{reader}, $local{sender}, undef, 0.1);

    foreach my $fh (@{$sockets[1]}) {
        if ($users{$fh}{nick}) { print "Sending to $users{$fh}{hostname} ($users{$fh}{nick}): $users{$fh}{recv_buf}\n" }
        else { print "Sending to $users{$fh}{hostname}: $users{$fh}{recv_buf}\n" }
        my $write = syswrite($fh, $users{$fh}{recv_buf}, $local{buf_size});
        if (!$write) { warn "Error sending data to $users{$fh}{nick}: $!\nData will be lost.\n" }
        $users{$fh}{recv_buf} = '';
        $local{sender}->remove($fh);
    }

    foreach my $fh (@{$sockets[0]}) {
        if ($fh == $local{listen}) {
            my $fh = $local{listen}->accept;
            $local{reader}->add($fh);
            send_user_msg_serv($fh, "NOTICE AUTH :*** Looking up your hostname...");
            (my $value, $users{$fh}{hostname}) = look_up_host($fh);
            if (!$value) { send_user_msg_serv($fh, "NOTICE AUTH :*** Hostname not resolved. Using IP instead: ($users{$fh}{hostname})") }
            else { send_user_msg_serv($fh, "NOTICE AUTH :*** Hostname found: $users{$fh}{hostname}") }
            $users{$fh}{connected} = 0;
        }

        else {                
            my $sent_buf = '';
            my $read = sysread($fh, $sent_buf, $local{buf_size});
            if ($read) {
                my @bufs = split(/\n/, $sent_buf);
                foreach my $args (@bufs) {
                    if ($users{$fh}{nick}) { print "Received from $users{$fh}{hostname} ($users{$fh}{nick}): $args\n" }
                    else { print "Received from $users{$fh}{hostname}: $args\n" }
                    process_command($fh, $args);
                }
            }
                
            else { push @clients_to_disconnect, $fh }
            # If data can't be read, the client disconnected and their respective data should be cleaned up.
        }
    }

    if ($clients_to_disconnect[0]) { disconnect_dead_clients() } # Don't call disconnect_dead_clients if there are none.
}

# To prevent confusion on the subroutines that accept multi-word arguments:
# my ($fh, $output) = @_ works because even though the output may be
# multiple words, it is passed as one argument in a double-quoted string.

###########################################################################
# Subroutines to send data:
###########################################################################


# Sends data prefixed with the user's full address. Used for messages.
sub send_user_msg_addr {
    my ($fh, $output) = @_;
    my $message = join '', ':', $users{$fh}{nick}, '!', $users{$fh}{username}, '@', "$users{$fh}{hostname} ";
    $message .= $output . "\n";
    $users{$fh}{recv_buf} .= $message;
    $local{sender}->add($fh); 
}

# Sends data prefixed with the server name. Used for data that doesn't have a numeric, like server notices.
sub send_user_msg_serv {
    my ($fh, $output) = @_;
    my $message = ":$local{server} ";
    $message .= $output . "\n";
    $users{$fh}{recv_buf} .= $message;
    $local{sender}->add($fh);
}

# Send exactly what we're given. Used for all other messages.
sub send_user_msg_raw {
    my ($fh, $output) = @_;
    my $message .= $output . "\n";
    $users{$fh}{recv_buf} .= $message;
    $local{sender}->add($fh);
}

# Sends data prefixed with the server name and the supplied numeric. Used for server numerics.
sub send_user_msg_num {
    # The filehandle and numeric are shifted off so that any other arguments can be grabbed as necessary.
    my ($fh, $numeric) = ((shift), (shift));
    my $message = '';
    if ($users{$fh}{connected}) { $message = ":" . "$local{server} $numeric $users{$fh}{nick} " }
    else { $message = ":" . "$local{server} $numeric * " }
    
    if ($numeric == 1) {
        my ($nick, $username, $hostname) = @_;
        $message .= join '', ":Welcome to the $local{network} IRC Network $nick", '!', $username, '@', $hostname;
    }
    elsif ($numeric == 2) {
        $message .= ":Your host is $local{server}, running version $local{version}";
    }
    elsif ($numeric == 3) { $message .= ":This server was created $local{start_date}"; }
    elsif ($numeric == 251) {
        my ($non_invisible_users, $invisible_users, $servers) = @_;
        $message .= ":There are $non_invisible_users users and $invisible_users invisible on $servers servers";
    }
    elsif ($numeric == 252) {
        my ($operators) = @_;
        $message .= "$operators :operator(s) online";
    }
    elsif ($numeric == 253) { $message .= "0 :unknown connection(s)"; }
    elsif ($numeric == 254) {
        my ($channels) = @_;
        $message .= "$channels :channels formed";
    }
    elsif ($numeric == 255) {
        my ($users, $servers) = @_;
        $message .= ":I have $users clients and $servers servers";
    }
    elsif ($numeric == 265) {
        my ($users, $record_users) = @_;
        $message .= ":Current Local Users: $users  Max: $record_users";
    }
    elsif ($numeric == 266) {
        my ($users, $record_users) = @_;
        $message .= ":Current Global Users: $users  Max: $record_users";
    }
    elsif ($numeric == 311) {
        my ($nick, $username, $hostname, $realname) = @_;
        $message .= "$nick $username $hostname * $realname";
    }
    elsif ($numeric == 312) {
        my ($nick) = @_;
        $message .= "$nick $local{server} :"."$local{server_desc}";
    }
    elsif ($numeric == 318) {
        my ($nick) = @_;
        $message .= "$nick :End of /WHOIS list.";
    }
    elsif ($numeric == 372) {
        my ($text) = @_;
        $message .= ":- $text";
    }
    elsif ($numeric == 375) {
        $message .= ":- $local{server} Message of the Day -";
    }
    elsif ($numeric == 376) { $message .= ":End of /MOTD command."; }
    elsif ($numeric == 401) {
        my ($nick) = @_;
        $message .= "$nick :No such nick";
    }
    elsif ($numeric == 421) {
        my ($command) = @_;
        $message .= "$command :Unknown command or command not yet implemented";
    }
    elsif ($numeric == 422) { $message .= ":MOTD File is missing"; }
    elsif ($numeric == 431) { $message .= ":No nickname given"; }
    elsif ($numeric == 432) {
        my ($nick, $reason) = @_;
        if (!$reason) { $message .= "$nick :Erroneus Nickname" }
        else { $message .= "$nick :Erroneus Nickname: $reason" }
    }
    elsif ($numeric == 433) {
        my ($nick) = @_;
        $message .= "$nick :Nickname is already in use.";
    }
    elsif ($numeric == 451) {
        my ($command) = @_;
        $message .= "$command :Register first";
    }
    elsif ($numeric == 461) {
        my ($command) = @_;
        $message .= "$command :Not enough parameters";
    }
    elsif ($numeric == 462) { $message .= ":You may not reregister"; }
    else {
        warn "Invalid numeric $numeric used.\n";
        return;
    }

    $message .= "\n";
    $users{$fh}{recv_buf} .= $message;
    $local{sender}->add($fh);
}

###########################################################################
# Subroutines to handle logging on:
###########################################################################

# Does DNS and reverse DNS to find socket's full and real host.
sub look_up_host {
    my ($fh) = @_;
    my $other_end = getpeername($fh);
    my $iaddr = (unpack_sockaddr_in($other_end))[1];
    my $actual_ip = inet_ntoa($iaddr);
    my $claimed_hostname = gethostbyaddr($iaddr, AF_INET);
    my $name_lookup = (gethostbyname($claimed_hostname))[0];
    if (!$name_lookup) {
        print "Client connected: $actual_ip\n";
        my (@values) = (0, $actual_ip);
        return @values;
    }
    print "Client connected: $name_lookup\n";
    my (@values) = (1, $name_lookup);
    @values;
}

# Occurs after NICK and USER are received and user is registered.
sub new_logon {
    my ($fh) = @_;
    $local{users}++;
    $local{record_users} = max($local{users}, $local{record_users});
    $local{non_invisible_users}++;
    send_user_msg_num($fh, $RPL_WELCOME, $users{$fh}{nick}, $users{$fh}{username}, $users{$fh}{hostname});
    send_user_msg_num($fh, $RPL_YOURHOST);
    send_user_msg_num($fh, $RPL_CREATED);
    serv_lusers($fh);
    serv_motd($fh);    
}

###########################################################################
# Subroutines to handle incoming commands:
###########################################################################

# Used to get a command and redirect it to the proper subroutine to handle the command.
# Also returns an error for unknown commands.
sub process_command {
    my ($fh, $args) = @_;
    my $command = (split / /, $args)[0];
    
    if    ($command =~ /^user$/i)    { serv_user($fh, $args)    }
    elsif ($command =~ /^nick$/i)    { serv_nick($fh, $args)    }
    elsif (!$users{$fh}{connected})  { send_user_msg_num($fh, $ERR_NOTREGISTERED, $command) }
    # That's to catch anyone trying to send any other commands when they're not registered.
    elsif ($command =~ /^privmsg$/i) { serv_privmsg($fh, $args) }
    elsif ($command =~ /^whois$/i)   { serv_whois($fh, $args)   }
    elsif ($command =~ /^lusers$/i)  { serv_lusers($fh)         }
    elsif ($command =~ /^motd$/i)    { serv_motd($fh)           }
    elsif ($command =~ /^notice$/i)  { serv_privmsg($fh, $args) }
    elsif ($command =~ /^online$/i)  { serv_online($fh)         }

    else {
        $command =~ tr/A-Z/a-z/;
        send_user_msg_num($fh, $ERR_UNKNOWNCOMMAND, $command)
    }
}

# Handles the user command. If NICK has already been issued, logs on.
sub serv_user {
    my ($fh, $args) = @_;
    my @user_info = split / /, $args;
    if (!$users{$fh}{connected}) {
        if (@user_info < 5) { send_user_msg_num($fh, $ERR_NEEDMOREPARAMS, "USER") }
        else {
            $users{$fh}{username} = '~' . $user_info[1];
            print "$users{$fh}{username}\n";
            for (4..$#user_info) {
                if ($_ ne $#user_info) { $users{$fh}{realname} .= "$user_info[$_] " }
                else { $users{$fh}{realname} .= $user_info[$_] }
            }
            if ($users{$fh}{nick_done}) {
                $users{$fh}{connected} = 1;
                delete $users{$fh}{nick_done};
                new_logon($fh);
            }
            else { $users{$fh}{user_done} = 1 }
        }
    }
           
    else { send_user_msg_num($fh, $ERR_ALREADYREGISTERED) }
}

# Handles the nick command. If NICK has already been issued, logs on.
# Also handles nick changes.
sub serv_nick {
    my ($fh, $args) = @_;
    my $nick = (split / /, $args)[1];
    $nick =~ s/^\://;
    my $nick_cs = nick_ison($nick);
    if (!$users{$fh}{connected}) {
        if (!$nick) {
            send_user_msg_num($fh, $ERR_NONICKNAMEGIVEN);
            return;
        }
        
        # a-z A-Z 0-9 ^ _ - ` \ [ ] { } | are the valid characters. Nick can't start with a digit. Ugly regex, I know.

        elsif ((length($nick) > 30) || ($nick =~ /^[0-9]/) ||
        ($nick =~ /[^a-zA-Z0-9\^_\-\`\\\[\]\{\}\|]/) || ($nick =~ /^\-/)) {
            send_user_msg_num($fh, $ERR_ERRONEUSNICKNAME, $nick);
            return;
        }

        elsif ($nick =~ /^NickServ$/i) {
            send_user_msg_num($fh, $ERR_ERRONEUSNICKNAME, 'NickServ', 'No password stealing. Thanks.');
            return;
        }

        elsif ($nick_cs) {
            send_user_msg_num($fh, $ERR_NICKNAMEINUSE, $nick_cs);
            return;
        }
        
        else {
            $users{$fh}{nick} = $nick;
            $fhs{$nick} = $fh;
            if ($users{$fh}{user_done}) {
                $users{$fh}{connected} = 1;
                delete $users{$fh}{user_done};
                new_logon($fh);
            }
            else { $users{$fh}{nick_done} = 1 }
        }
    }
    else {
        if (!$nick) {
            send_user_msg_num($fh, $ERR_NONICKNAMEGIVEN);
            return;
        }

        elsif ($nick eq $users{$fh}{nick}) { return }

        elsif ((length($nick) > 30) || ($nick =~ /^[0-9]/) ||
        ($nick =~ /[^a-zA-Z0-9\^_\-\`\\\[\]\{\}\|]/) || ($nick =~ /^\-/)) {
            send_user_msg_num($fh, $ERR_ERRONEUSNICKNAME, $nick);
            return;
        }

        elsif ($nick =~ /^NickServ$/i) {
            send_user_msg_num($fh, $ERR_ERRONEUSNICKNAME, 'NickServ', 'No password stealing. Thanks.');
            return;
        }         

        elsif (($nick_cs) && ($fhs{$nick_cs} != $fh)) {
            send_user_msg_num($fh, $ERR_NICKNAMEINUSE, $nick_cs);
            return;
        }
        
        else {
            # We have to send_user_msg_addr first so that the nick message comes out with the proper address:
            send_user_msg_addr($fh, "NICK :$nick");
            my $old_nick = $users{$fh}{nick};
            delete $fhs{$old_nick};
            $fhs{$nick} = $fh;
            $users{$fh}{nick} = $nick;
        }
    }
}

# Sends off NOTICEs and PRIVMSGs.
sub serv_privmsg {
    my ($fh, $args) = @_;
    my $nick = (split / /, $args)[1];
    my $nick_cs = nick_ison($nick);
    if (!$nick_cs) {
        send_user_msg_num($fh, $ERR_NOSUCHNICK, $nick);
        return;
    }
    else {
        my $receiving_fh = $fhs{$nick_cs};
        my $message = join '', ':', $users{$fh}{nick}, '!', $users{$fh}{username}, '@', "$users{$fh}{hostname} $args";
        send_user_msg_raw($receiving_fh, $message);
    }
}

# Returns whois data about a nick.
sub serv_whois {
    my ($fh, $args) = @_;
    my $nick = (split / /, $args)[1];
    my $nick_cs = nick_ison($nick);
    if (!$nick_cs) {
        send_user_msg_num($fh, $ERR_NOSUCHNICK, $nick);
        send_user_msg_num($fh, $RPL_ENDOFWHOIS, $nick);
    }

    else {
        my $fh_of_whoised_nick = $fhs{$nick_cs};
        send_user_msg_num($fh, $RPL_WHOISUSER, $users{$fh_of_whoised_nick}{nick}, $users{$fh_of_whoised_nick}{username}, $users{$fh_of_whoised_nick}{hostname}, $users{$fh_of_whoised_nick}{realname});
        send_user_msg_num($fh, $RPL_WHOISSERVER, $users{$fh_of_whoised_nick}{nick});
        send_user_msg_num($fh, $RPL_ENDOFWHOIS, $users{$fh_of_whoised_nick}{nick});
    }
}

# Returns server connection data.
sub serv_lusers {
    my ($fh) = @_;
    calc_global_nums();
    send_user_msg_num($fh, $RPL_LUSERCLIENT, $global{non_invisible_users}, $global{invisible_users}, $global{servers});
    send_user_msg_num($fh, $RPL_LUSEROP, $global{operators});
    send_user_msg_num($fh, $RPL_LUSERUNKNOWN);
    send_user_msg_num($fh, $RPL_LUSERCHANNELS, $global{channels});
    send_user_msg_num($fh, $RPL_LUSERME, $local{users}, $local{servers});
    send_user_msg_num($fh, $RPL_LOCALUSERS, $local{users}, $local{record_users});
    send_user_msg_num($fh, $RPL_GLOBALUSERS, $global{users}, $global{record_users});
}

# Returns the message of the day.

sub serv_motd {
    my ($fh) = @_;
    if (!open(MOTD, $local{motd_file})) {
        send_user_msg_num($fh, $ERR_NOMOTD);
        warn "MOTD could not be opened: $!\n";
    }
    else {
        send_user_msg_num($fh, $RPL_MOTDSTART);
        while (<MOTD>) { send_user_msg_num($fh, $RPL_MOTD, $_) }
        close MOTD;
        send_user_msg_num($fh, $RPL_ENDOFMOTD);
    }
}

# Used by the message of the day to calculate user sums.
# Since there's no multi-user, the globals are given the same as their local counterparts
sub calc_global_nums() {
    $global{users}               = $local{users};
    $global{record_users}        = $local{record_users};
    $global{invisible_users}     = $local{invisible_users};
    $global{non_invisible_users} = $local{non_invisible_users};
#   $global{servers}             = $local{servers}; # Except for this, since the two numbers are always different.
    $global{operators}           = $local{operators};
    $global{channels}            = $local{channels};
}

sub serv_online {
    my ($fh) = @_;
    send_user_msg_serv($fh, "NOTICE :Current online members: ");
    foreach my $nick (sort keys %fhs) {
        send_user_msg_serv($fh, "NOTICE :$nick");
    }
}

###########################################################################
# Other subroutines:
###########################################################################

# Used to disconnect and clear the data of any clients that have disconnected.
sub disconnect_dead_clients {
    foreach my $fh (@clients_to_disconnect) {
        shift @clients_to_disconnect;
        print "Client disconnected: $users{$fh}{hostname}\n";
        $local{reader}->remove($fh);
        $local{sender}->remove($fh);
        my $nick = $users{$fh}{nick};
        if ($nick) { delete $fhs{$nick} }
        $local{non_invisible_users}--;
        delete $users{$fh};
        $local{users}--;
        $fh->close; # Oddly enough, if I do this any sooner, it screws up.
    }
}

# Tests to see whether or not a nick is online. Case insensitive search, returns case sensitive value of nick.
sub nick_ison {
    my ($nick) = @_;
    print "nick is $nick\n";
    foreach my $online_nick (keys %fhs) {
        print "online_nick is $online_nick\n";
        if ($nick =~ /^($online_nick)$/i) { print "THEY MATCH!\n"; return $online_nick }
    }
    return;
}

# Finds the max and min of two numbers.
sub max { ($_[0] > $_[1]) ? $_[0] : $_[1] }
# sub min { ($_[0] < $_[1]) ? $_[0] : $_[1] }

# Supply a date to show when the server was started.
sub get_date {
    my @days = qw/ Sun Mon Tue Wed Thu Fri Sat /;
    my @months = qw/ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec /;
    my @time_info = (localtime)[0, 1, 2, 3, 4, 5, 6, 8];
    my $start_time = sprintf("%s %s %02d %04d at %02d:%02d:%02d %s", $days[$time_info[6]], $months[$time_info[4]],
                                                                     $time_info[3], $time_info[5] + 1900, $time_info[2],
                                                             $time_info[1], $time_info[0], $time_info[7] ? 'CDT' : 'CST');
    $start_time;
}