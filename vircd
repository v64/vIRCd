#!/usr/bin/perl

use strict; # Like every good program, this one starts with use strict;
use warnings;
use v5.6.1;
use IO::Select;
use IO::Socket;
use Socket;

# Some initialization:

###############################################################################
# We're just gonna get this out of the way right now because it's big and ugly.
# These define all the server numerics:
#
# Note: Numeric 462 was originally ERR_ALREADYREGISTRED (not REGISTERED).
# Why this legacy typo has stayed in for so long is beyond me.
# I'm taking it out.
###############################################################################
use constant RPL_WELCOME           => '001';
use constant RPL_YOURHOST          => '002';
use constant RPL_CREATED           => '003';
use constant RPL_LUSERCLIENT       => '251';
use constant RPL_LUSEROP           => '252';
use constant RPL_LUSERUNKNOWN      => '253';
use constant RPL_LUSERCHANNELS     => '254';
use constant RPL_LUSERME           => '255';
use constant RPL_LOCALUSERS        => '265';
use constant RPL_GLOBALUSERS       => '266';
use constant RPL_WHOISUSER         => '311';
use constant RPL_WHOISSERVER       => '312';
use constant RPL_ENDOFWHOIS        => '318';
use constant RPL_MOTD              => '372';
use constant RPL_MOTDSTART         => '375';
use constant RPL_ENDOFMOTD         => '376';
use constant ERR_NOSUCHNICK        => '401';
use constant ERR_UNKNOWNCOMMAND    => '421';
use constant ERR_NONICKNAMEGIVEN   => '431';
use constant ERR_NICKNAMEINUSE     => '433';
use constant ERR_NEEDMOREPARAMS    => '461';
use constant ERR_ALREADYREGISTERED => '462';
###############################################################################

# Will be replaced to be read from a config file.
use constant VERSION     => 'Veachian-0.09';
use constant NETWORK     => 'V64net';
use constant SERVER      => 'G42.V64.net';
use constant SERVER_DESC => 'The Veachian IRCd - Written entirely in the Perl programming language.';

my @days = qw/ Sun Mon Tue Wed Thu Fri Sat /;
my @months = qw/ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec /;
# Supply a date to show when the server was started.
my @local_time = (localtime)[0, 1, 2, 3, 4, 5, 6, 8];
use constant START_TIME => sprintf("%s %s %02d %04d at %02d:%02d:%02d %s", $days[$local_time[6]], $months[$local_time[4]],
                                                         $local_time[3], $local_time[5] + 1900, $local_time[2],
                                                         $local_time[1], $local_time[0], $local_time[7] ? 'CDT' : 'CST');

use constant MOTD => 'vircd.motd';
use constant PORT => '4242';

my $serv_listen;   # Socket listener.
my $serv_readable; # Basically a list of every connecting socket. Reads data from them.
my $serv_writable; # All sockets with data that needs to be sent to them.

my %users = (); # Hash containing all filehandles of clients and their info. Ex. $users{$filehandle}{nick}
my %local = (); # Hash containing all local info for the server. Ex. $local{users}
my %global = (); # Hash containing all global info for the network. Ex. $global{users}
my %fhs = (); # Hash containing nicks and their filehandles. Ex. $fhs{nick}
my @clients_to_disconnect = (); # Array containing a list of filehandles that have disconnected.

$local{users} = 0;
$global{users} = 0;
$local{record_users} = 0;
$global{record_users} = 0;
$local{invisible_users} = 0;
$global{invisible_users} = 0;
$local{non_invisible_users} = 0;
$global{non_invisible_users} = 0;
$local{servers} = 0;
$global{servers} = 1;
$local{operators} = 0;
$global{operators} = 0;
$local{channels} = 0;
$global{channels} = 0;

######################################################################################################################
# Some more detailed hash info:
# ${local}{data}     - Data local to the server.
#    users               - Users on the server.
#    record_users        - Record (max) number of users.
#    invisible_users     - Usermode +i clients on the server.
#    non_invisible_users - Usermode -i clients on the server.
#    servers             - Servers server is linked to, excluding self.
#    operators           - IRCops on the server.
#    channels            - Channels started by a client on that server.
#    {nicks}{$nick}      - Returns true if nick exists, false if not.
#    {fh}{$nick}         - The filehandle to a client knowing only their nick.
# $global{data}      - Data local to the network.
#    users               - Users on the network.
#    record_users        - Record (max) number of users.
#    invisible_users     - Usermode +i clients on the network.
#    non_invisible_users - Usermode -i clients on the network.
#    servers             - Total servers on the network.
#    operators           - IRCops on the network.
#    channels            - Channels on the server.
# $users{$fh}{data}  - Information about that unique filehandle/socket/client.
#    recv_buf            - The buffer containing all data ready to be received by the client.
#    sent_buf            - The buffer containing all data ready to be read from the client.
#    nick                - Nickname of the client.
#    hostname            - Real hostname of the client.
#    username            - Ident as reported by USER. Not real, prefixed with a ~.
#    connected           - Used by NICK and USER to tell whether or not the client is connected or in pre-connection.
#    real_name           - The client's real name as reported for a /whois.
# $fhs{data}         - Used to retrieve a client's filehandle knowing only their nick.
#    nick                - Returns the filehandle of the user with that nick. Also used as a list of all logged on nicks.
#
# Other variables used throughout the program in a local scope:
# $fh                    - Filehandle to the current socket we're dealing with.
# $args                  - The arguments provided to a subroutine.
# $output                - Like $args, but used to retrieve the message in subroutines that send data.
# $message               - $message is the final result after $output is formatted for the current task.
######################################################################################################################

print "Starting $version...\n";

$serv_listen = IO::Socket::INET->new(LocalPort => $port,
                                     Listen    => 10,
                                     Proto     => 'tcp',
                                     Reuse     => 1)
or die "Unable to creating listening socket.\n";

$serv_readable = IO::Select->new();
$serv_readable->add($serv_listen);
$serv_writable = IO::Select->new();
$serv_writable->add($serv_listen);

print "Server running.\n";

run_server();
exit;

# The subroutine is kept as compact as it can.
sub run_server {
    while (1) {
        my @ready = IO::Select->select($serv_readable, $serv_writable, undef, 0.1);

        foreach my $fh (@{$ready[1]}) { write_data($fh) }

        foreach my $fh (@{$ready[0]}) {
            if ($fh == $serv_listen) {
                process_login($fh);
            }

            else {                
                my $read = sysread($fh, $users{$fh}{sent_buf}, 3072);
                if ($read) { read_data($fh) } # We don't have to pass the buffer because it's global.
                
                else { push @clients_to_disconnect, $fh }
                # If data can't be read, the client disconnected and their respective data should be cleaned up.
            }
        }

        if ($clients_to_disconnect[0]) { disconnect_dead_clients() } # Don't call disconnect_dead_clients if there are none.
    }
}

# To prevent confusion on the subroutines that accept multi-word arguments:
# my ($fh, $output) = @_ works because even though the output may be
# multiple words, it is passed as one argument in a double-quoted string.

###########################################################################
# Subroutines to send data:
###########################################################################


# Sends data prefixed with the user's full address. Used for messages.
sub send_user_msg_addr {
    my ($fh, $output) = @_;
    my $message = ':'."$users{$fh}{nick}".'!'."$users{$fh}{username}".'@'."$users{$fh}{hostname} ";
    $message .= $output . "\n";
    $users{$fh}{recv_buf} .= $message;
    $serv_writable->add($fh); 
}

# Sends data prefixed with the server name. Used for data that doesn't have a numeric, like server notices.
sub send_user_msg_serv {
    my ($fh, $output) = @_;
    my $message = ":$server ";
    $message .= $output . "\n";
    $users{$fh}{recv_buf} .= $message;
    $serv_writable->add($fh);
}

# Sends data prefixed with the server name and the supplied numeric. Users for server numerics.
# The filehandle and numeric are shifted off so that any other arguments can be grabbed as necessary.
sub send_user_msg_num {
    my ($fh, $numeric) = ((shift), (shift));
    my $message = '';
    if ($users{$fh}{connected}) { $message = ":" SERVER $numeric $users{$fh}{nick} " }
    else { $message = ":" SERVER "$numeric * " }
    
    if ($numeric eq '001') {
        my ($nick, $username, $hostname) = @_;
        $message .= ":Welcome to the " NETWORK " IRC Network $nick".'!'."$username".'@'."$hostname";
    }
    elsif ($numeric eq '002') { $message .= ":Your host is " SERVER ", running version " VERSION; }
    elsif ($numeric eq '003') { $message .= ":This server was created " START_TIME; }
    elsif ($numeric eq '251') {
        my ($non_invisible_users, $invisible_users, $servers) = @_;
        $message .= ":There are $non_invisible_users users and $invisible_users invisible on $servers servers";
    }
    elsif ($numeric eq '252') {
        my ($operators) = @_;
        $message .= "$operators :operator(s) online";
    }
    elsif ($numeric eq '253') { $message .= "0 :unknown connection(s)"; }
    elsif ($numeric eq '254') {
        my ($channels) = @_;
        $message .= "$channels :channels formed";
    }
    elsif ($numeric eq '255') {
        my ($users, $servers) = @_;
        $message .= ":I have $users clients and $servers servers";
    }
    elsif ($numeric eq '265') {
        my ($users, $record_users) = @_;
        $message .= ":Current Local Users: $users  Max: $record_users";
    }
    elsif ($numeric eq '266') {
        my ($users, $record_users) = @_;
        $message .= ":Current Global Users: $users  Max: $record_users}";
    }
    elsif ($numeric eq '311') {
        my ($nick, $username, $hostname, $real_name) = @_;
        $message .= "$nick $username $hostname} * $real_name";
    }
    elsif ($numeric eq '312') {
       my ($nick) = @_;
       $message .= "$nick " SERVER ":" SERVER_DESC;
    }
    elsif ($numeric eq '318') { $message .= ":End of /WHOIS list."; }
    elsif ($numeric eq '372') {
       my ($text) = @_;
       $message .= ":- $text";
    }
    elsif ($numeric eq '375') { $message .= ":- " SERVER " Message of the Day -"; }
    elsif ($numeric eq '376') { $message .= ":End of /MOTD command."; }
    elsif ($numeric eq '401') {
       my ($nick) = @_;
       $message .= "$nick :No such nick";
    }
    elsif ($numeric eq '421') {
      my ($command) = @_;
      $message .= "$command :Unknown command or command not yet implemented";
    }
    elsif ($numeric eq '431') { $message .= ":No nickname given"; }
    elsif ($numeric eq '433') {
      my ($nick) = @_;
      $message .= "$nick :Nickname is already in use.";
    }
    elsif ($numeric eq '461') {
      my ($command) = @_;
      $message .= "$command :Not enough parameters";
    }
    elsif ($numeric eq '462') { $message .= ":You may not reregister"; }
    else { warn "Invalid numeric $numeric used.\n"; }

    $message .= "\n";
    $users{$fh}{recv_buf} .= $message;
    $serv_writable->add($fh);
}

# Send exactly what we're given. Used for all other messages.
sub send_user_msg_raw {
    my ($fh, $output) = @_;
    my $message .= $output . "\n";
    $users{$fh}{recv_buf} .= $message;
    $serv_writable->add($fh);
}

###########################################################################
# Subroutines to handle logging on:
###########################################################################

# Accepts the new client and gives it its own filehandle. Sends server notices regarding hostname and calls
# look_up_host() to find the hostname.
sub process_login {
    my $fh = $serv_listen->accept;
    $serv_readable->add($fh);
    send_user_msg_serv($fh, "NOTICE AUTH :*** Looking up your hostname...");
    my $value;
    ($value, $users{$fh}{hostname}) = look_up_host($fh);
    if (!$value) { send_user_msg_serv($fh, "NOTICE AUTH :*** Hostname not resolved. Using IP instead: ($users{$fh}{hostname})") }
    else { send_user_msg_serv($fh, "NOTICE AUTH :*** Hostname found: $users{$fh}{hostname}") }
    $users{$fh}{connected} = 0;
}

# Does DNS and reverse DNS to find socket's full and real host.
sub look_up_host {
    my ($fh) = @_;
    my $other_end = getpeername($fh);
    my $iaddr = (unpack_sockaddr_in($other_end))[1];
    my $actual_ip = inet_ntoa($iaddr);
    my $claimed_hostname = gethostbyaddr($iaddr, AF_INET);
    my $name_lookup = (gethostbyname($claimed_hostname))[0];
    if (!$name_lookup) {
        print "Client connected: $actual_ip\n";
        my (@values) = (0, $actual_ip);
        return @values;
    }
    print "Client connected: $name_lookup\n";
    my (@values) = (1, $name_lookup);
    @values;
}

# Occurs after NICK and USER are received and user is registered.
sub new_logon {
    my ($fh) = @_;
    $local{users}++;
    $local{record_users} = max($local{users}, $local{record_users});
    $local{non_invisible_users}++;
    send_user_msg_num($fh, RPL_WELCOME, $users{$fh}{nick}, $users{$fh}{username}, $users{$fh}{hostname});
    send_user_msg_num($fh, RPL_YOURHOST);
    send_user_msg_num($fh, RPL_CREATED);
    serv_lusers($fh);
    serv_motd($fh);    
}

###########################################################################
# Subroutines to handle incoming commands:
###########################################################################

sub write_data {
    my ($fh) = @_;
    my $write = syswrite($fh, $users{$fh}{recv_buf}, 3072);
    if (!$write) { warn "Error sending data to $users{$fh}{nick}: $!\nData will be lost.\n" }
    $users{$fh}{recv_buf} = '';
    $serv_writable->remove($fh);
}

sub read_data {
    my ($fh) = @_;
    my @bufs = split(/\n/, $users{$fh}{sent_buf});
    $users{$fh}{sent_buf} = '';
    foreach my $args (@bufs) {
        if ($users{$fh}{nick}) { print "Received from $users{$fh}{hostname} ($users{$fh}{nick}): $args\n" }
        else { print "Received from $users{$fh}{hostname}: $args\n" }
        process_command($fh, $args);
    }
}

# Used to get a command and redirect it to the proper subroutine to handle the command.
# Also returns an error for unknown commands.
sub process_command {
    my ($fh, $args) = @_;
    my $command = (split /\s+/, $args)[0];
    $command =~ tr/A-Z/a-z/;
    $command .= ' ';

    if    ($command =~ m/^user /)    { serv_user($fh, $args)    }
    elsif ($command =~ m/^nick /)    { serv_nick($fh, $args)    }
    elsif ($command =~ m/^privmsg /) { serv_privmsg($fh, $args) }
    elsif ($command =~ m/^whois /)   { serv_whois($fh, $args)   }
    elsif ($command =~ m/^lusers /)  { serv_lusers($fh)         }
    elsif ($command =~ m/^motd /)    { serv_motd($fh)           }
    elsif ($command =~ m/^notice /)  { serv_privmsg($fh, $args) }
    elsif ($command =~ m/^online /)  { serv_online($fh)         }

    else { send_user_msg_num($fh, ERR_UNKNOWNCOMMAND, $command) }
}

# Handles the user command. If NICK has already been issued, logs on.
sub serv_user {
    my ($fh, $args) = @_;
    my @user_info = split /\s+/, $args;
    if (!$users{$fh}{connected}) {
        if (@user_info < 5) { send_user_msg_num($fh, ERR_NEEDMOREPARAMS, "USER") }
        else {
            $users{$fh}{username} = '~' . $user_info[1];
            for (4..$#user_info) {
                if ($_ ne $#user_info) { $users{$fh}{real_name} .= "$user_info[$_] " }
                else { $users{$fh}{real_name} .= $user_info[$_] }
            }
        }
    }
           
    if ($users{$fh}{nick}) {
        $users{$fh}{connected} = 1;
        new_logon($fh);
    }

    else { send_user_msg_num($fh, ERR_ALREADYREGISTERED) }
}

# Handles the nick command. If NICK has already been issued, logs on.
# Also handles nick changes.
sub serv_nick {
    my ($fh, $args) = @_;
    if (!$users{$fh}{connected}) {
        my $nick = (split /\s+/, $args)[1];
        $nick =~ s/://;
        if (!$nick) {
            send_user_msg_num($fh, ERR_NONICKNAMEGIVEN);
            return;
        }
        
        elsif ($users{local}{nicks}{$nick}) {
            send_user_msg_num($fh, ERR_NICKNAMEINUSE, $nick);
            return;
        }
        
        else {
            $users{$fh}{nick} = $nick;
            $users{local}{nicks}{$nick} = 1;
            $users{local}{fh}{$nick} = $fh;
        }

        if ($users{$fh}{username}) {
            $users{$fh}{connected} = 1;
            new_logon($fh);
        }
    }
    else {
        my $nick = (split /\s+/, $args)[1];
        $nick =~ s/://;
        if (!$nick) {
            send_user_msg_num($fh, ERR_NONICKNAMEGIVEN);
            return;
        }

        elsif ($nick eq $users{$fh}{nick}) { return }

        elsif ($users{local}{nicks}{$nick}) {
            send_user_msg_num($fh, ERR_NICKNAMEINUSE, $nick);
            return;
        }
        
        else {
            send_user_msg_addr($fh, "NICK :$nick");
            my $old_nick = $users{$fh}{nick};
            delete $users{local}{nicks}{$old_nick};
            $users{local}{nicks}{$nick} = 1;
            $users{local}{fh}{$nick} = $fh;
            delete $users{local}{fh}{$old_nick};
            $users{$fh}{nick} = $nick;
        }
    }
}

# Sends off NOTICEs and PRIVMSGs.
sub serv_privmsg {
    my ($fh, $args) = @_;
    my $nick = (split /\s+/, $args)[1];
    if (!$users{local}{nicks}{$nick}) {
        send_user_msg_num($fh, ERR_NOSUCHNICK, $nick);
        return;
    }
    else {
        my $send_to_fh = get_fh_from_nick($nick);
        send_user_msg_raw($send_to_fh, ":"."$users{$fh}{nick}"."!"."$users{$fh}{username}"."@"."$users{$fh}{hostname} $args");
    }
}

# Used by serv_privmsg() to retrieve the socket for the owner of a nick.
# Used to know where to send a message to a nick.
sub get_fh_from_nick {
    my ($nick) = @_;
    $users{local}{fh}{$nick};
}

# Returns whois data about a nick.
sub serv_whois {
    my ($fh, $args) = @_;
    my $nick = (split /\s+/, $args)[1];
    if (!$users{local}{nicks}{$nick}) {
        send_user_msg_num($fh, ERR_NOSUCHNICK, $nick);
        send_user_msg_num($fh, RPL_ENDOFWHOIS);
        return;
    }

    else {
        my $fh_of_nick = get_fh_from_nick($nick);
        send_user_msg_num($fh, RPL_WHOISUSER, $users{$fh_of_nick}{nick}, $users{$fh_of_nick}{username}, $users{$fh_of_nick}{hostname}, $users{$fh_of_nick}{real_name});
        send_user_msg_num($fh, RPL_WHOISSERVER, $users{$fh_of_nick}{nick});
        send_user_msg_num($fh, RPL_ENDOFWHOIS);
    }
}

# Returns server connection data.
sub serv_lusers {
    my ($fh) = @_;
    calc_global_nums();
    send_user_msg_num($fh, RPL_LUSERCLIENT, $users{global}{non_invisible_users}, $users{global}{invisible_users}, $users{global}{servers});
    send_user_msg_num($fh, RPL_LUSEROP, $users{global}{operators});
    send_user_msg_num($fh, RPL_LUSERUNKNOWN);
    send_user_msg_num($fh, RPL_LUSERCHANNELS, $users{global}{channels});
    send_user_msg_num($fh, RPL_LUSERME, $users{local}{users}, $users{local}{servers});
    send_user_msg_num($fh, RPL_LOCALUSERS, $users{local}{users}, $users{local}{record_users});
    send_user_msg_num($fh, RPL_GLOBALUSERS, $users{global}{users}, $users{global}{record_users});
}

# Returns the message of the day.
sub serv_motd {
    my ($fh) = @_;
    send_user_msg_num($fh, RPL_MOTDSTART);
    open(MOTD, "<vircd.motd") or warn "Error opening MOTD: $!\n";
    while (<MOTD>) { send_user_msg_num($fh, RPL_MOTD, $_) }
    close MOTD;
    send_user_msg_num($fh, RPL_ENDOFMOTD);
}

# Used by the message of the day to calculate user sums.
# Since there's no multi-user, the globals are given the same as their local counterparts
sub calc_global_nums() {
    $users{global}{users}               = $users{local}{users};
    $users{global}{record_users}        = $users{local}{record_users};
    $users{global}{invisible_users}     = $users{local}{invisible_users};
    $users{global}{non_invisible_users} = $users{local}{non_invisible_users};
#   $users{global}{servers}             = $users{local}{servers}; # Except for this, since the two numbers are always different.
    $users{global}{operators}           = $users{local}{operators};
    $users{global}{channels}            = $users{local}{channels};
}

sub serv_online {
    my ($fh) = @_;
    send_user_msg_serv($fh, "NOTICE :Current online members: ");
    foreach my $nick (keys %{$users{local}{nicks}}) {
        send_user_msg_serv($fh, "NOTICE :$nick");
    }
}

###########################################################################
# Other subroutines:
###########################################################################

# Used to disconnect and clear the data of any clients that have disconnected.
sub disconnect_dead_clients {
    foreach my $fh (@clients_to_disconnect) {
        shift @clients_to_disconnect;
        print "Client disconnected: $users{$fh}{hostname}\n";
        $serv_readable->remove($fh);
        $serv_writable->remove($fh);
        my $nick = $users{$fh}{nick};
        delete $users{local}{$nick};
        delete $users{local}{fh}{$nick};
        if (!$users{$fh}{mode}{i}) { $users{local}{non_invisible_users}-- }
        else { $users{local}{invisible_users}-- }
        delete $users{$fh};
        $users{local}{users}--;
        $fh->close;
    }
}

# Finds the max and min of two numbers.
sub max { ($_[0] > $_[1]) ? $_[0] : $_[1] }
sub min { ($_[0] < $_[1]) ? $_[0] : $_[1] }
